% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Logger.R
\name{Logger}
\alias{Logger}
\alias{Loggers}
\title{Loggers}
\description{
A Logger produces a \link{LogEvent} that contains the log message along with
metadata (timestamp, calling function) and dispatches it to one or several
\link{Appenders} which are responsible for the output (console, file, ...) of the
event. \strong{lgr} comes with a single pre-configured Logger called the
\verb{root Logger} that can be accessed via \verb{lgr$<...>}. Instantiation of new
Loggers is only necessary if you want to take advantage of hierarchical
logging as outlined in \code{vignette("lgr", package = "lgr")}.
}
\details{
\describe{
\item{\code{fatal(msg, ..., caller = get_caller(-8L))}}{Logs a message with
level \code{fatal} on this logger. If there are \emph{unnamed} arguments in \code{...},
they will be passed to \code{base::sprintf()} along with message. Named
arguments will be passed as custom fields to \link{LogEvent}. If there are named
arguments the names must be unique. \code{caller} refers to the name of the
calling function and if specified manually must be a \code{character} scalar.}

\item{\code{error(msg, ..., caller = get_caller(-8L))}}{Logs a message with level \code{error} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{warn(msg, ..., caller = get_caller(-8L))}}{Logs a message with level \code{warn} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{info(msg, ..., caller = get_caller(-8L))}}{Logs a message with level \code{info} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{debug(msg, ..., caller = get_caller(-8L))}}{Logs a message with level \code{debug} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{trace(msg, ..., caller = get_caller(-8L))}}{Logs a message with level \code{trace} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{log(level, msg, ..., timestamp, caller)}}{
If the \code{level} passes the Logger \code{threshold} a new \link{LogEvent}
with \code{level}, \code{msg}, \code{timestamp} and \code{caller} is created. Unnamed
arguments in \code{...} will be combined with \code{msg} via \code{base::sprintf()}.
Named arguments in \code{...} will be passed on to \code{LogEvent$new()} as custom
fields. If no unnamed arguments are present, \code{msg} will \emph{not} be passed
to \code{sprintf()}, so in that case you do not have to escape \code{"\%"}
characters.
If the new LogEvent passes this Loggers filters, it will be dispatched
to the relevant \link{Appenders} and checked against their thresholds and
filters.
}

\item{\verb{config(cfg, file, text, list}}{Load a Logger
configuration. \code{cfg} can be either
\itemize{
\item a special list object with any or all of the the following elements:
\code{appenders}, \code{threshold}, \code{filters}, \code{propagate}, \code{exception_handler},
\item the path to a \code{YAML}/\code{JSON} config file,
\item a \code{character} scalar containing \code{YAML},
\item \code{NULL} (to reset the logger config to the default/unconfigured state)
}

The arguments \code{file}, \code{text} and \code{list} can be used as an alternative to
\code{cfg} that  enforces that the  supplied  argument is of the specified
type. See \link{logger_config} for details.
}

\item{\code{add_appender(appender, name = NULL)}, \code{remove_appender(pos)}}{
Add or remove an \link{Appender}. Supplying a \code{name} is optional but
recommended. After adding an Appender with
\code{logger$add_appender(AppenderConsole$new(), name = "console")} you can
refer to it via \code{logger$appenders$console}. \code{remove_appender()} can
remove an Appender by position or name.
}
}
}
\note{
If you are a package developer you should define a new Logger for each
package, but you do not need to configure it. The user of the package
should decide how and where to output logging, usually by configuring the
root Logger (new Appenders added/removed, Layouts modified, etc...).
}
\examples{
# lgr::lgr is the root logger that is always available
lgr$info("Today is a good day")
lgr$fatal("This is a serious error")

# Loggers use sprintf() for string formatting by default
lgr$info("Today is \%s", Sys.Date() )

# If no unnamed `...` are present, msg is not passed through sprintf()
lgr$fatal("100\% bad")  # so this works
lgr$fatal("\%s\%\% bad", 100)  # if you use unnamed arguments, you must escape \%

# You can create new loggers with get_logger()
tf <- tempfile()
lg <- get_logger("mylogger")$set_appenders(AppenderFile$new(tf))

# The new logger passes the log message on to the appenders of its parent
# logger, which is by default the root logger. This is why the following
# writes not only the file 'tf', but also to the console.
lg$fatal("blubb")
readLines(tf)

# This logger's print() method depicts this relationship.
child <- get_logger("lg/child")
print(child)
print(child$name)

# use formatting strings and custom fields
tf2 <- tempfile()
lg$add_appender(AppenderFile$new(tf2, layout = LayoutJson$new()))
lg$info("Not all \%s support custom fields", "appenders", type = "test")
cat(readLines(tf), sep = "\n")
cat(readLines(tf2), sep = "\n")

# cleanup
unlink(c(tf, tf2))
lg$config(NULL)  # reset logger config

# LoggerGlue
# You can also create a new logger that uses the awesome glue library for
# string formatting instead of sprintf

if (requireNamespace("glue")){

  lg <- get_logger_glue("glue")
  lg$fatal("blah ", "fizz is set to: {fizz}", foo = "bar", fizz = "buzz")
  # prevent creation of custom fields with prefixing a dot
  lg$fatal("blah ", "fizz is set to: {.fizz}", foo = "bar", .fizz = "buzz")

  #' # completely reset 'glue' to an unconfigured vanilla Logger
  get_logger("glue", reset = TRUE)

}


# Configuring a Logger
lg <- get_logger("test")
lg$config(NULL)  # resets logger to unconfigured state

# With setters
lg$
  set_threshold("error")$
  set_propagate(FALSE)$
  set_appenders(AppenderConsole$new(threshold = "info"))

lg$config(NULL)

# With a list
lg$config(list(
  threshold = "error",
  propagate = FALSE,
  appenders = list(AppenderConsole$new(threshold = "info"))
))

lg$config(NULL)  # resets logger to unconfigured state

# Via YAML
cfg <- "
Logger:
  threshold: error
  propagate: false
  appenders:
    AppenderConsole:
      threshold: info
"

lg$config(cfg)
lg$config(NULL)

## ------------------------------------------------
## Method `Logger$list_log`
## ------------------------------------------------

lg <- get_logger("test")
lg$list_log(list(level = 400, msg = "example"))
}
\seealso{
\href{https://glue.tidyverse.org/}{glue}

\code{\link[=get_logger]{get_logger()}}
}
\section{Super class}{
\code{\link[lgr:Filterable]{lgr::Filterable}} -> \code{Logger}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{name}}{A \code{character} scalar. The unique name of each logger,
which also includes the names of its ancestors (sepparated by \code{/}).}

\item{\code{propagate}}{A \code{TRUE} or \code{FALSE}. The unique name of each logger,
which also includes the names of its ancestors (sepparated by \code{/}).}

\item{\code{last_event}}{The last LogEvent produced by the current Logger}

\item{\code{ancestry}}{A named \code{logical} vector of containing the propagate value
of each Logger upper the inheritance tree. The names are the names of
the appenders. \code{ancestry} is an S3 class with a custom
\code{format()}/\code{print()} method, so if you want to use the plain logical
vector use \code{unclass(lg$ancestry)}}

\item{\code{parent}}{a \code{Logger}. The direct ancestor of the \code{Logger}.}

\item{\code{threshold}}{\code{integer} scalar. The threshold of the \code{Logger}, or if it
\code{NULL} the threshold it inherits from its closest ancestor with a
non-\code{NULL} threshold}

\item{\code{inherited_appenders}}{A \code{list} of all appenders that the Logger inherits from
its ancestors}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{Logger$new()}}
\item \href{#method-log}{\code{Logger$log()}}
\item \href{#method-fatal}{\code{Logger$fatal()}}
\item \href{#method-error}{\code{Logger$error()}}
\item \href{#method-warn}{\code{Logger$warn()}}
\item \href{#method-info}{\code{Logger$info()}}
\item \href{#method-debug}{\code{Logger$debug()}}
\item \href{#method-trace}{\code{Logger$trace()}}
\item \href{#method-list_log}{\code{Logger$list_log()}}
\item \href{#method-config}{\code{Logger$config()}}
\item \href{#method-add_appender}{\code{Logger$add_appender()}}
\item \href{#method-remove_appender}{\code{Logger$remove_appender()}}
\item \href{#method-handle_exception}{\code{Logger$handle_exception()}}
\item \href{#method-set_exception_handler}{\code{Logger$set_exception_handler()}}
\item \href{#method-set_propagate}{\code{Logger$set_propagate()}}
\item \href{#method-set_threshold}{\code{Logger$set_threshold()}}
\item \href{#method-set_appenders}{\code{Logger$set_appenders()}}
\item \href{#method-spawn}{\code{Logger$spawn()}}
}
}
\if{html}{
\out{<details open ><summary>Inherited methods</summary>}
\itemize{
\item \out{<span class="pkg-link" data-pkg="lgr" data-topic="Filterable" data-id="add_filter">}\href{../../lgr/html/Filterable.html#method-add_filter}{\code{lgr::Filterable$add_filter()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="lgr" data-topic="Filterable" data-id="filter">}\href{../../lgr/html/Filterable.html#method-filter}{\code{lgr::Filterable$filter()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="lgr" data-topic="Filterable" data-id="remove_filter">}\href{../../lgr/html/Filterable.html#method-remove_filter}{\code{lgr::Filterable$remove_filter()}}\out{</span>}
\item \out{<span class="pkg-link" data-pkg="lgr" data-topic="Filterable" data-id="set_filters">}\href{../../lgr/html/Filterable.html#method-set_filters}{\code{lgr::Filterable$set_filters()}}\out{</span>}
}
\out{</details>}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
\strong{Loggers should never be instantiated directly with \code{Logger$new()}} but
rather via \code{\link[=get_logger]{get_logger("name")}}. This way new Loggers are
registered in a global namespace which ensures uniqueness and
facillitates inheritance between Loggers. If \code{"name"} does not exist, a
new Logger with that name will be created, otherwise the function returns
a Reference to the existing Logger.

\code{name} is potentially a \code{"/"} separated hierarchical value like
\code{foo/bar/baz}. Loggers further down the hierarchy are descendents of the
loggers above and (by default) inherit \code{threshold} and \code{Appenders} from
their ancestors.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$new(
  name = "(unnamed logger)",
  appenders = list(),
  threshold = NULL,
  filters = list(),
  exception_handler = default_exception_handler,
  propagate = TRUE
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-log"></a>}}
\subsection{Method \code{log()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$log(level, msg, ..., timestamp = Sys.time(), caller = get_caller(-7))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fatal"></a>}}
\subsection{Method \code{fatal()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$fatal(msg, ..., caller = get_caller(-8L))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-error"></a>}}
\subsection{Method \code{error()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$error(msg, ..., caller = get_caller(-8L))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-warn"></a>}}
\subsection{Method \code{warn()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$warn(msg, ..., caller = get_caller(-8L))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-info"></a>}}
\subsection{Method \code{info()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$info(msg, ..., caller = get_caller(-8L))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-debug"></a>}}
\subsection{Method \code{debug()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$debug(msg, ..., caller = get_caller(-8L))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-trace"></a>}}
\subsection{Method \code{trace()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$trace(msg, ..., caller = get_caller(-8L))}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-list_log"></a>}}
\subsection{Method \code{list_log()}}{
\code{list_log()} is a shortcut for do.call(Logger$log).
See \url{https://github.com/s-fleck/joblog} for an R package that
leverages this feature to create custom log event types for tracking
the status of cron jobs.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$list_log(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{a named \code{list} that must at least contain the named elements
\code{level} and \code{timestamp}}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{lg <- get_logger("test")
lg$list_log(list(level = 400, msg = "example"))
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-config"></a>}}
\subsection{Method \code{config()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$config(cfg, file, text, list)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-add_appender"></a>}}
\subsection{Method \code{add_appender()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$add_appender(appender, name = NULL)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-remove_appender"></a>}}
\subsection{Method \code{remove_appender()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$remove_appender(pos)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-handle_exception"></a>}}
\subsection{Method \code{handle_exception()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$handle_exception(...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_exception_handler"></a>}}
\subsection{Method \code{set_exception_handler()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$set_exception_handler(fun)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_propagate"></a>}}
\subsection{Method \code{set_propagate()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$set_propagate(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{\code{TRUE} or \code{FALSE}. Should \link{LogEvents} be passed on to the appenders
of the ancestral Loggers?}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_threshold"></a>}}
\subsection{Method \code{set_threshold()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$set_threshold(level)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_appenders"></a>}}
\subsection{Method \code{set_appenders()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$set_appenders(x)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-spawn"></a>}}
\subsection{Method \code{spawn()}}{
Spawn a child Logger. This is very similar to using \code{\link[=get_logger]{get_logger()}}, but
can be useful in some cases where Loggers are created programmatically
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Logger$spawn(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{`name`}}{\code{character} vector. Name of the child logger
\code{get_logger("foo/bar")$spawn("baz")} is equivalent
to \code{get_logger("foo/bar/baz")}}
}
\if{html}{\out{</div>}}
}
}
}
