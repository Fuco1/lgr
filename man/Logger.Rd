% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Logger.R
\name{Logger}
\alias{Logger}
\alias{Loggers}
\title{Loggers}
\description{
A Logger produces a \link{LogEvent} that contains the log message along with
metadata (timestamp, calling function) and dispatches it to one or several
\link{Appenders} which are responsible for the output (console, file, ...) of the
event. \strong{lgr} alread comes with a single pre-configured Logger called the
\code{root Logger} that can be accessed via \code{lgr$<...>}. Instantiation of new
Loggers is only necessary if you want to take advantage of hierarchical
logging as outlined in \code{vignette("lgr", package = "lgr")}.
}
\section{Usage}{
\preformatted{
x <- x$new(name = "(unnamed logger)", appenders = list(), threshold = 400L,
  filters = NULL, user = get_user(), parent = lgr::lgr,
  exception_handler = default_exception_handler, propagate = TRUE)

x$log(level, msg, ..., timestamp = Sys.time(), caller = get_caller(-7))
x$fatal(msg, ...)
x$error(msg, ...)
x$warn(msg, ...)
x$info(msg, ...)
x$debug(msg, ...)
x$trace(msg, ...)
x$add_appender(appender, name = NULL)
x$remove_appender(pos)
x$handle_exception(...)
x$set_name(x)
x$set_exception_handler(fun)
x$set_propagate(x)
x$set_parent(logger)
x$set_threshold(level)
x$set_appenders(x)
x$set_user(x)
x$filter(event)
x$set_filters(filters)

x$ancestry
x$appenders
x$exception_handler
x$inherited_appenders
x$last_event
x$name
x$parent
x$propagate
x$threshold
x$user
x$filters

}
}

\section{Creating Loggers}{


If you want logging for a Project (f.e a Package you are developing) that is
separate from the global logging, you can create a new logger with
\code{Logger$new()}. If you just want to add different outputs (for example
logfiles) to the root Logger, look into \link{Appenders}.
}

\section{Fields}{


You can either specify these fields in \code{Logger$new()} or modify them after
creation with setter functions of the form \code{logger$set_<fieldname>(value)}
(see examples)

\describe{
\item{\code{name}, \code{set_name(x)}}{\code{character} scalar. A name for the Logger that should be
unique amongst Loggers. This logger name is used in the Loggers print
method and can be used by Appenders to indicate which logger the
log message came from. If you define a Logger for an R Package (the most
common case for defining new Loggers), the logger name should be the
same name as the Package name. If you do not define a Logger name
manually, a warning will be thrown.}

\item{\code{appenders}, \code{set_appenders(x)}}{A single \link{Appender} or a \code{list}
thereof. Appenders control the output of a Logger. Be aware that a Logger
also inherits the Appenders of its ancestors
(see \code{vignette("lgr", package = "lgr")} for more info about Logger
inheritance structures).}

\item{\code{threshold}, \code{set_threshold(level)}}{\code{character} or \code{integer} scalar.
The minimum \link[=log_levels]{log level} that triggers this Logger}

\item{\code{user}, \code{set_user(x)}}{\code{character} scalar. The current user name or
email adress. This information is saved so that it can be used by the
Appenders}

\item{\code{parent}, \code{set_parent(logger)}}{a \code{Logger}. Usually the root logger.
Can also be \code{NULL}, but all Loggers must be descentents of the root logger
for lgr to work as intended.}

\item{\code{exception_handler}, \code{set_exception_handler()}}{a \code{function} that
takes a single argument \code{e}. The function used to handle errors that occur
durring loging. Defaults to demoting errors to \link{warnings}.}

\item{\code{propagate}, \code{set_propagate()}}{\code{TRUE} or \code{FALSE}. Should LogEvents
be passed on to the appenders of the ancestral Loggers?}
}



\describe{
\item{\code{filters}, \code{set_filters(filters)}}{a \code{list} of predicates (functions
that return either \code{TRUE} or \code{FALSE}). These functions must have exactly
two arguments: \code{event} and \code{obj}. When the \code{filter()} method of the
Filterable is invoked on a LogEvent, that event will get passed to \code{event},
the Filterable will get passed to \code{obj}. This means that you can,
f.e. use \code{obj$threshold} to access the threshold of the Appender/Logger
that is using the filter.
If all of these functions evaluate to \code{TRUE} the LogEvent is passed on.
Since LogEvents have reference semantics, filters can also be abused to
modify them before they are passed on. Look at the source code of
\code{\link[=with_log_level]{with_log_level()}} or \code{\link[=with_log_value]{with_log_value()}} for examples.
}
}
}

\section{Read-Only Bindings}{


In addition to the active bindings used to access the fields described above,
Loggers also have the following additional read-only bindings:

\describe{
\item{\code{ancestry}}{A named \code{logical} vector of containing
the propagate value of each Logger upper the inheritance tree. The names
are the names of the appenders.}

\item{\code{inherited_appenders}}{A \code{list} of all inherited
appenders from ancestral Loggers of the current Logger}

\item{\code{last_event}}{The last LogEvent produced by the current Logger}
}
}

\section{Methods}{


\describe{
\item{\code{fatal(msg, ...)}}{Logs a message with level \code{fatal} on this logger.
If there are \emph{unnamed} arguments in \code{...}, they will be pased to
\code{base::sprintf()} along with message. Named arguments will be passed
as custom fields to \link{LogEvent}. If there are named arguments the names
must be unique}

\item{\code{error(msg, ...)}}{Logs a message with level \code{error} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{warn(msg, ...)}}{Logs a message with level \code{warn} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{info(msg, ...)}}{Logs a message with level \code{info} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{debug(msg, ...)}}{Logs a message with level \code{debug} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{trace(msg, ...)}}{Logs a message with level \code{trace} on this logger.
The arguments are interpreted as for \code{fatal()}.}

\item{\code{log(level, msg, ..., timestamp, caller)}}{
If the \code{level} passes the Logger \code{threshold} a new \link{LogEvent}
with \code{level}, \code{msg}, \code{timestamp} and \code{caller} is created. Unnamed
arguments in \code{...} will be combined with \code{msg} via \code{base::sprintf()}.
Named arguments in \code{...} will be passed on to \code{LogEvent$new()} as custom
fields. If no unnamed arguments are present, \code{msg} will \emph{not} be passed
to \code{sprintf()}, so in that case you do not have to escape \code{"\%"}
characters.#'
If the new LogEvent passes this Loggers filters, it will be dispatched
to the relevant \link{Appenders} and checked against their thresholds and
filters.
}

\item{\code{add_appender(appender, name = NULL)}}{Adds a new Appender to the
Logger. \code{appender} must be an \link{Appender} object. \code{name} is optional and
will be used as name in the list of appenders, i.e if you do
\code{logger$add_appender(AppenderConsole$new(), name = "console")} you can
refer to it via \code{logger$appenders$console}.}

\item{\code{remove_appender(pos)}}{Removes and Appender from a Logger. \code{pos}
can be an \code{integer} or \code{character} vector referring either to the positions
or names of the Appenders to be removed.}
}


\describe{
\item{\code{filter(event)}}{Determine whether the LogEvent \code{x} should be passed
on to Appenders (\code{TRUE}) or not (\code{FALSE}). See also the active binding
\code{filters}}
}
}

\examples{

lgr$info("Today is \%s", Sys.Date() )

# lgr includes a pre-configured root logger
lgr$fatal("This is a serious error")

# if you want to take advantage of hierarchical logging, you can create new loggers.
# the following creates a new logger that logs to a temporary file.
tf <- tempfile()
lg <- Logger$new(
  "mylogger",
  appenders = AppenderFile$new(tf)
)

# The new logger passes the log message on to the appenders of its parent
# logger, which is by default the root logger. This is why the following
# writes not only the file 'tf', but also to the console.
lg$fatal("blubb")
readLines(tf)

# This relationship is also depicted in the loggers print method
print(lg)
print(lg$ancestry)

# use formatting strings and custom fields
tf2 <- tempfile()
lg$add_appender(AppenderFile$new(tf2, layout = LayoutJson$new()))
lg$info("Not all \%s support custom fields", "appenders", type = "test")
readLines(tf)
readLines(tf2)

# This works because if no unnamed `...` are present, msg is not passed
# through sprintf()
lg$fatal("100\%")

}
