% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Layout.R
\name{LayoutDbi}
\alias{LayoutDbi}
\alias{LayoutSqlite}
\alias{LayoutRjdbc}
\title{Format Log Events for Output to Databases}
\description{
DBI Layouts convert \link{LogEvents} to a \code{data.frames} that can
be appended to an existing database table. Via the \code{col_types} parameter
they can also store information that \link{AppenderDbi} can use to create new
database tables; however, it is safer and more flexible to set up the log
table up manually with an \code{SQL CREATE TABLE} statement instead.
}
\section{Usage}{
\preformatted{
x <- x$new(event_values = NULL, col_types = NULL)

x$format_event(event)
x$set_col_types(x)
x$sql_create_table(table)
x$clone(deep = FALSE)
x$set_event_values(x)
x$set_val_names(x)

x$col_names
x$col_types
x$event_values
x$val_names

}
}

\section{Creating a New Layout}{




Layouts are instantiated with \code{<LayoutSubclass>$new()}. For a description of
the arguments to this function please refer to the Fields section.
}

\section{Fields}{


\describe{
\item{\code{col_types}}{A named \code{character} vector of column types supported by
the target database. If this is used instead of \code{event_values}, and
the target logging \code{table} does not yet exist, the column type
information is used by \link{AppenderDbi} or similar Appenders to create a
new database table, either on instantion of the Appender or on writing
of the first LogEvent. If the target database table already exists,
the column type information is not used. You can only supply one of
\code{event_values} and \code{col_types}.
}
\item{\code{col_names}}{Convenience method to get the names of the \code{col_types}
vector}
}
}

\section{Methods}{




\describe{
\item{\code{format_event(event)}}{format a \link{LogEvent}}
}
}

\section{Database Specific Layouts}{


Different databases have different data types and features. Currently the
following \code{LayoutDBI} subclasses exist that deal with specific databases,
but this list is expected to grow as lgr matures:
\itemize{
\item \code{LayoutSQLite}: Needs its own Layout because SQLite does not support
\code{timestamps}
\item \code{LayoutDBI}: For all other datbases
}

The utility function \code{\link[=select_dbi_layout]{select_dbi_layout()}} returns the appropriate
Layout for a DBI connection.
}

\examples{
# setup a dummy LogEvent
event <- LogEvent$new(
  logger = Logger$new("dummy logger", user = "testuser"),
  level = 200,
  timestamp = Sys.time(),
  caller = NA_character_,
  msg = "a test message"
)

# defaults
lo <- LayoutDbi$new()
lo$format_event(event)

# SQLite does not support timestamps so LayoutSqlite converts them to text
lo <- LayoutSqlite$new()
str(lo$format_event(event))

# advanced example that supports a custom_field:
lo <- LayoutDbi$new(
  col_types =  c(
    timestamp = "timestamp",
    level = "smallint",
    msg = "varchar(2048)",
    custom_field = "integer"
  )
)

event <- LogEvent$new(
  logger = Logger$new("dummy logger", user = "testuser"),
  level = 200,
  timestamp = Sys.time(),
  caller = NA_character_,
  msg = "a test message",
  custom_field = "blubb"
)

lo$format_event(event)

}
\seealso{
\code{\link[=select_dbi_layout]{select_dbi_layout()}}, \link[DBI:DBI]{DBI::DBI},

Other Layouts: \code{\link{LayoutFormat}},
  \code{\link{LayoutGlue}}, \code{\link{LayoutJson}},
  \code{\link{LayoutTable}}, \code{\link{Layout}}
}
\concept{Layouts}
\concept{database layouts}
